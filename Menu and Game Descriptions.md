# Menu and Game Descriptions
All games run on a 60Hz clock to run at the same tick rate as the display as calculating other frames is unnecessary. There is a game select screen to handle the enabling and disabling of different games. To access any game, use the up arrow or down arrow key to hover over a game and the enter key to begin running the game. Within any game, use the escape key to go back to the game select screen. If a game is still running when going to the game select screen, the game will be paused.

```
WARNING: 
THIS PAGE HAS NOT BEEN DEVELOPED FULLY, READ AT YOUR OWN CAUTION, IT MAY NOT MAKE ANY SENSE
```

## Pong
The classic pong game with two controllable paddles on either side of the screen and a ball which bounces off of the paddles and top and bottom edges. The left paddle is controlled by the `W` and `S` keys while the right paddle is controlled by the `up arrow` and `down arrow` keys. With the scores of either player going up to 15 points before a winner is crowned.

To achieve simultaneous inputs, I created a PS2 keyboard controller which used the negative edge of the PS2 clock line `PS2_CLK` to read the serial output of the PS2 data line `PS2_DAT`, composed of 11 bits of data, 1 start bit, 8 data bits, 1 parity bit and 1 stop bit. The parity bit is an odd parity bit, meaning including the data bits and parity bit, there should be an odd number of high bits sent. Using this information, `make` and `break` codes can be derived and interpreted to toggle flags for specific keys. The toggle flags allowed for multiple key presses to be registered and held. Additional information can be found on the [PS2 Input Protocol Page](PS2%20Input%20Protocol.md).

To achieve the physics, I created a custom hardware-based physics engine. An paired set of registers and wires are used to represent the current positions/velocities, and the next positions/velocities respectively. When the next frame is supposed to be calculated, the FPGA does a check to make sure it is in bounds. If the ball intersects the paddle or goes out of bounds of the visible screen, the ball's new velocity, and position is calculated with this collision in mind. To detect bounds, I used the side effect of utilizing the requirement of 10 bit wide registers and wires to fully cover all values on the visible screen; this gives a segment of unused values which can be used to detect overflows and their types; for example, if the next position lands on the left half of the overflow region, we know it was travelling rightward.

To achieve the score display, I created a module based on a previously created hex decoder as a basis to create a score display capable of showing 4 bit numbers in decimal format. Simply turning on or off overlapping rectangle regions, I simulated a score display. I also took into account the horizontal shift required for the right side scores as when hitting the double digits, the number shifts.
## Dino
Based on the offline `Dinosaur Game` by Google, was the second game I recreated. To give a more in depth gaming experience, I created more advance modules, including an advanced physics engine, a unique hit box detection, an entity system, a randomizer and a sprite renderer.

To achieve more advanced physics based on the pong physics engine, I implemented gravity based physics onto the dinosaur and control so the player can have a short or high jump by either tapping or holding the jump button. With the rapidly changing positive and negative values, I had to shift the velocity values by 128 to ensure consistent behaviour. With additional checks and unique behaviour wires like, max velocity, normal fall velocity, slow fall velocity, stop velocity and a jump counter to track the time in the air. Additionally, the further you reach in the game, the faster the player runs.

To achieve hit detection, I created a custom hit detection system. For each object, I began with a 32x32 hit box and modified the bird to have a thinner height, and modified the cactus to have a thinner width and a height based on the size of the cactus sprite. Hit detection has smaller hit boxes to allow for more easy game play as it can be frustrating if the dinosaur is running too fast and you die because you hit one pixel which feels unfair.

To achieve entities, I created multiple instances of the cactus registers and bird registers. Using similar techniques from game design, I have 4 bird entities and 4 cactus entities to avoid large amounts of computations. After going off screen on the left, all entities get stored at the right most value (1023) and when the cooldown (responsible for keeping the cactus and birds spaced) goes to 0, a bird or cactus respectively gets 'dispatched' and begins to move to the left. Although you often don't notice the 4 entity limit, it allows for future add-ons like an increase in difficulties or challenges.

To achieve randomness, I implemented a randomizer module responsible for adding randomness to the system. It uses the 50MHz clock and 4 prime number counters, of which, the last 2 bits of each are placed in an output value. With each counter overflowing at different rates, this simulates random values. This randomizer is constantly running in the background and is 'random' based on the amount of time that has passed. This allows the game to have a semi randomized game as it is inhuman to be able to start the game at the exact same nanosecond. This randomizer is implemented into the height of the birds, the height of the cactus and the 'cooldown' of both the birds and cactus.

To achieve sprites, I used the block memory and created sprite maps for the dino game for all the assets. This includes, birds, dinosaur, cactuses, and the numbers. Because I had a sprite map to reduce the amount of space used, I created a custom address module which took the type of sprite that needed to be displayed (using the underlying box hit boxes) and found the correct address to get the value. Additionally, I had a custom RGB layout which allows for the sprite to overlap and where there are transparent pixels on the foreground sprite, the FPGA will display the background sprite (`A-RRRRR-BBBBB-GGGGG`).

## Game Select
To achieve switching between games and pausing, I used finite state machines. I added a finite state machine for both games to handle the end game, pausing and starting state. For pong, I have a `start`, `game`, `pause` and `end` state. The `start` state will always reset all registers for a new game; the `game` state runs all the physics and scoring; the `pause` state occurs when hitting escape; and the `end` state occurs when a player hits 16 points and wins a match. To play a new game or unpause, the state machine waits for a `space` key press. While for dino, I have a `start`, `game`, `pause`, `end_check` and `end` state. The main difference is the end_check state which ensures the user isn't holding the space bar and immediately starting the next game. These state machines also operate at the same time as the game select finite state machine (which handles overarching behaviour). It has `hover_pong`, `load_pong`, `ingame_pong`, `hover_dino`, `load_dino`, `ingame_dino` states. You can observe the hover states when you hit escape and can switch between the pong and dino game. During the hover states, I disable both dino and pong on top of the two games going into a paused state when exiting to the game select menu; additionally, the display outputs of the games are disabled and a new video controller is routed to the display module to be displayed. The load states are responsible for loading any assets if need be like scores. The ingame states simply re enable the games and reroutes the display signals to the respective display module.

To achieve the ASCII characters, I created a sprite map rom module based on the DINO sprite ROM concept but dedicated to a different format where I store 8x16 character sprites with 1 byte for each row as binary on/off. I created an ASCII ROM which has all the capital and lowercase alphabets and a handful of special characters. Although I didn't showcase many characters, I have the full file loaded onto the FPGA via a MIF file. This type of rendering also allows for recolouring of the background and text colour. Additional information can be found on the [MIF Scripts Page](MIF%20Scripts.md).